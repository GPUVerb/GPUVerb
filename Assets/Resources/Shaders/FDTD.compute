// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KernFDTD
#pragma kernel KernZero
#pragma kernel KernTest
#pragma kernel KernAddBounds
#pragma kernel KernRemoveBounds

struct Cell {
	float pressure;
	float velX;
	float velY;
	int   b;
};
struct BoundaryInfo {
	float absorption;
};

// used by FDTD
RWStructuredBuffer<BoundaryInfo> boundaries;
RWStructuredBuffer<Cell>       grid;
RWStructuredBuffer<Cell>       gridOut;
StructuredBuffer<Cell>         gridIn;
StructuredBuffer<float>        gaussianPulse;
float2                         listenerPos;
int3                           gridDim; // (x dim, y dim, time dim)
int                            curTime;
float                          courant;

// used by geometry updates
int4 updateDim;

#define IDX(i,j,dim) ((i) * dim[0] + (j))
#define VALID(i,j,dim) ((i) < dim[1] && (j) < dim[0])

int GetB_Out(int i, int j) {
	return gridOut[IDX(i, j, gridDim)].b & 0xffff;
}
int GetBy_Out(int i, int j) {
	return gridOut[IDX(i, j, gridDim)].b >> 16 & 0xffff;
}
int GetB_In(int i, int j) {
	return gridIn[IDX(i, j, gridDim)].b & 0xffff;
}
int GetBy_In(int i, int j) {
	return gridIn[IDX(i, j, gridDim)].b >> 16 & 0xffff;
}

void WriteB(int val, int i, int j) {
	gridOut[IDX(i, j, gridDim)].b &= 0xffff0000; // little endian, so it's not 0x0000ffff
	gridOut[IDX(i, j, gridDim)].b |= val & 0xffff;
}
void WriteBy(int val, int i, int j) {
	gridOut[IDX(i, j, gridDim)].b &= 0x0000ffff;
	gridOut[IDX(i, j, gridDim)].b |= (val & 0xffff) << 16;
}

[numthreads(8, 8, 1)]
void KernTest(uint3 id : SV_DispatchThreadID) {
	const int i = id.y;
	const int j = id.x;

	if (!VALID(i, j, gridDim)) {
		return;
	}
	WriteB(GetB_In(i, j) + (i + 1) * (j + 1), i, j);
}

[numthreads(8, 8, 1)]
void KernZero(uint3 id : SV_DispatchThreadID) {
	const int i = id.y;
	const int j = id.x;

	if (!VALID(i,j,gridDim)) {
		return;
	}

	gridOut[IDX(i,j,gridDim)].pressure = 0;
	gridOut[IDX(i,j,gridDim)].velX     = 0;
	gridOut[IDX(i,j,gridDim)].velY     = 0;
}


// required binding: updateDim, gridDim, gridOut, boundaries
[numthreads(8, 8, 1)]
void KernRemoveBounds(uint3 id : SV_DispatchThreadID) {
	const int i = id.y;
	const int j = id.x;
	if (j >= updateDim[2] - updateDim[0] || i >= updateDim[3] - updateDim[1]) {
		return;
	}

	const int gi = i + updateDim[1];
	const int gj = j + updateDim[0];

	boundaries[IDX(gi, gj, gridDim)].absorption = 0;

	if(gi == gridDim[1] - 1 || gj == gridDim[0] - 1) {
		WriteB(0, gi, gj);
		WriteBy(0, gi, gj);
	} else if(gi == 0) {
		WriteB(1, gi, gj);
		WriteBy(0, gi, gj);
	} else {
		WriteB(1, gi, gj);
		WriteBy(1, gi, gj);
	}
}

// required binding: updateDim, gridDim, gridOut, boundaries
[numthreads(8, 8, 1)]
void KernAddBounds(uint3 id : SV_DispatchThreadID) {
	const int i = id.y;
	const int j = id.x;
	if (j >= updateDim[2] - updateDim[0] || i >= updateDim[3] - updateDim[1]) {
		return;
	}
	const int gi = i + updateDim[1];
	const int gj = j + updateDim[0];
	boundaries[IDX(gi, gj, gridDim)].absorption = 0;

	WriteB(0, gi, gj);
	WriteBy(0, gi, gj);
}

// A single iteration of FDTD solver
// required binding: 
//     gridDim, curTime, grid, gridIn, gridOut, boundaries, courant, listenerPos, gaussianPulse
// reads from gridIn and writes to gridOut
[numthreads(8, 8, 1)]
void KernFDTD(
	//uint3 groupID : SV_GroupID, 
	//uint3 groupThreadID : SV_GroupThreadID,
	//uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	const int i = id.y;
	const int j = id.x;

	if (!VALID(i, j, gridDim)) {
		return;
	}

	// first copy b from previous time step
	gridOut[IDX(i, j, gridDim)].b = gridIn[IDX(i, j, gridDim)].b;

	// pressure
	if (VALID(i + 1, j, gridDim) && VALID(i, j + 1, gridDim)) {
		const Cell c  = gridIn[IDX(i, j, gridDim)];
		const Cell cy = gridIn[IDX(i + 1, j, gridDim)];
		const Cell cx = gridIn[IDX(i, j + 1, gridDim)];

		const float divergence = (cx.velX - c.velX) + (cy.velY - c.velY);

		gridOut[IDX(i,j,gridDim)].pressure = GetB_In(i, j) * (c.pressure - courant * divergence);
	}

	GroupMemoryBarrierWithGroupSync();

	// velocity x
	if (VALID(i, j - 1, gridDim)) {
		const Cell c  = gridOut[IDX(i,j,gridDim)];
		const Cell cx = gridOut[IDX(i, j - 1, gridDim)];

		const float betaN = GetB_Out(i, j - 1);
		const float rn    = boundaries[IDX(i, j - 1, gridDim)].absorption;
		const float yn    = (1.f - rn) / (1.f + rn);
		const float beta  = GetB_Out(i, j);
		const float r     = boundaries[IDX(i,j,gridDim)].absorption;
		const float y     = (1.f - r) / (1.f + r);

		const float gradientX  = c.pressure - cx.pressure;
		const float airUpdate  = c.velX - courant * gradientX;
		const float yBoundary  = beta * yn + betaN * y;
		const float wallUpdate = yBoundary * (cx.pressure * betaN + c.pressure * beta);

		gridOut[IDX(i,j,gridDim)].velX = beta * betaN * airUpdate + (betaN - beta) * wallUpdate;
	}

	GroupMemoryBarrierWithGroupSync();


	// velocity Y
	if (VALID(i - 1, j, gridDim)) {
		const Cell c  = gridOut[IDX(i,j,gridDim)];
		const Cell cy = gridOut[IDX(i - 1, j, gridDim)];

		const float betaN = GetB_Out(i - 1, j);
		const float rn    = boundaries[IDX(i - 1, j, gridDim)].absorption;
		const float yn    = (1.f - rn) / (1.f + rn);
		const float beta  = GetB_Out(i, j);
		const float r     = boundaries[IDX(i,j,gridDim)].absorption;
		const float y     = (1.f - r) / (1.f + r);

		const float gradientY  = c.pressure - cy.pressure;
		const float airUpdate  = c.velY - courant * gradientY;
		const float yBoundary  = beta * yn + betaN * y;
		const float wallUpdate = yBoundary * (cy.pressure * betaN + c.pressure * beta);

		gridOut[IDX(i,j,gridDim)].velY = beta * betaN * airUpdate + (betaN - beta) * wallUpdate;
	}

	// top and bottom absorption
	if(j == 0) {
		gridOut[IDX(i, 0, gridDim)].velX = -gridOut[IDX(i, 0, gridDim)].pressure;
		gridOut[IDX(i, gridDim[0] - 1, gridDim)].velX = gridOut[IDX(i, gridDim[0] - 2, gridDim)].pressure;
	}
	if(i == 0) {
		// left and right absorption
		gridOut[IDX(0, j, gridDim)].velY = -gridOut[IDX(0, j, gridDim)].pressure;
		gridOut[IDX(gridDim[1] - 1, j, gridDim)].velY = gridOut[IDX(gridDim[1] - 2, j, gridDim)].pressure;
	}

	// write to grid
	grid[id.x * gridDim[1] * gridDim[2] + id.y * gridDim[2] + curTime] = gridOut[IDX(i, j, gridDim)];

	if(i == listenerPos[1] && j == listenerPos[0]) {
		// add pulse
		gridOut[IDX(i, j, gridDim)].pressure += gaussianPulse[curTime];
	}
}
